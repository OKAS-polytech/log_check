# 文字列探索アルゴリズム解説資料

本アプリケーションで採用している5つの文字列探索手法について解説する。

---

## 1. Naive Search (力まかせ探索)
最も基本的で直感的な手法。

- **原理**: テキストの先頭から1文字ずつ、パターンの全文字と一致するかを確認する。不一致があればパターンの位置を1つずらして再度比較する。
- **計算量**: テキスト長 $n$, パターン長 $m$ に対して最悪 $O(nm)$。
- **特徴**: 実装が非常に単純だが、繰り返しが多いテキストでは効率が極めて悪い。

## 2. Boyer-Moore (BM) アルゴリズム
実用上、非常に高速な探索手法の一つ。

- **原理**: パターンの「後ろ」から比較を行う。不一致が発生した際、パターンの情報を利用して「一気に大きくスキップ」するのが特徴。
  - **不一致文字規則 (Bad Character Rule)**: 不一致になった文字がパターンに含まれていれば、その文字が重なる位置までスキップ。
  - **一致接尾辞規則 (Good Suffix Rule)**: すでに一致した末尾部分の情報を利用してスキップ。
- **計算量**: 最良 $O(n/m)$, 最悪 $O(nm)$ (通常は $O(n)$ 以下)。
- **特徴**: パターンが長く、文字の種類が多い場合に極めて高いパフォーマンスを発揮する。

## 3. KMP (Knuth-Morris-Pratt) アルゴリズム
無駄な比較を避けるための先駆的な手法。

- **原理**: 探索に先立ち、パターンの「部分一致テーブル (LPS Table)」を作成する。不一致が起きた際、どこまで一致していたかという情報を利用して、テキスト側のポインタを戻さずに探索を継続する。
- **計算量**: 最悪 $O(n + m)$。
- **特徴**: どのような入力に対しても線形時間で動作することが保証されている。

## 4. Aho-Corasick アルゴリズム
複数のキーワードを一度に探索するための手法。

- **原理**: すべての検索パターンを組み込んだ「トライ木 (Trie)」を構築し、さらに不一致時の遷移先を示す「失敗リンク」を追加した有限オートマトンを作成する。テキストを1度走査するだけで、すべてのパターンの出現箇所を特定できる。
- **計算量**: テキスト長 $n$, 全パターンの合計長 $M$, ヒット数 $k$ に対して $O(n + M + k)$。
- **特徴**: 辞書に基づく検索やウイルススキャンなど、大量のキーワードを同時に探す場合に最適。

## 5. Bitap アルゴリズム (Fuzzy Search)
ビット演算を活用した、あいまい検索に強い手法。

- **原理**: パターンの一致状態をビット列として管理する。不一致文字を許容する場合（編集距離 $d > 0$）、ビットシフトと論理和演算によって「1文字置換・挿入・削除」の状態を並列的に更新する。
- **計算量**: $O(n \cdot m / w)$ （$w$ はワードサイズ）。編集距離を考慮する場合 $O(d \cdot n \cdot m / w)$。
- **特徴**: レーベンシュタイン距離を考慮した「近似一致」の検索が可能。パターン長がワードサイズ（通常64bit）以下であれば非常に高速。
